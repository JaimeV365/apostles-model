// src\components\reporting\services\DistanceCalculator.ts

import { DataPoint } from '../../../types/base';
import type { QuadrantType } from '../../visualization/context/QuadrantAssignmentContext';

export interface ProximityThresholds {
  conservative: number;
  moderate: number;
  sensitive: number;
}

export interface DistanceFromBoundary {
  toLeft: number;    // Distance to hostages (left boundary)
  toRight: number;   // Distance to mercenaries (right boundary) 
  toBottom: number;  // Distance to defectors (bottom boundary)
  toTop: number;     // Distance to loyalists/apostles (top boundary)
  minimum: number;   // Closest distance to any boundary
}

export class DistanceCalculator {
  private satisfactionScale: string;
  private loyaltyScale: string;
  private midpoint: { sat: number; loy: number };

  constructor(
    satisfactionScale: string,
    loyaltyScale: string, 
    midpoint: { sat: number; loy: number }
  ) {
    this.satisfactionScale = satisfactionScale;
    this.loyaltyScale = loyaltyScale;
    this.midpoint = midpoint;
  }

  /**
   * Get scale boundaries from scale strings
   */
  private getScaleBoundaries() {
    const satParts = this.satisfactionScale.split('-');
    const loyParts = this.loyaltyScale.split('-');
    
    return {
      satMin: parseInt(satParts[0]),
      satMax: parseInt(satParts[1]),
      loyMin: parseInt(loyParts[0]),
      loyMax: parseInt(loyParts[1])
    };
  }

  /**
   * Calculate space-aware proximity limits using small fixed distances from boundaries
   */
  private getSpaceAwareProximityLimits(quadrant: QuadrantType): {
    nearHostagesLimit?: number;
    nearMercenariesLimit?: number;
    nearLoyalistsLimit?: number;
    nearDefectorsLimit?: number;
  } {
    const boundaries = this.getScaleBoundaries();
    
    switch(quadrant) {
      case 'loyalists':
        return {
          nearHostagesLimit: this.midpoint.sat + 0.5,  // Only very close to hostages boundary
          nearMercenariesLimit: this.midpoint.loy + 1.5  // Reasonably close to mercenaries boundary
        };
      case 'mercenaries':
        return {
          nearLoyalistsLimit: boundaries.loyMax - 1.5,  // Close to top of scale
          nearDefectorsLimit: this.midpoint.loy - 1.5   // Close to bottom boundary
        };
      case 'hostages':
        return {
          nearLoyalistsLimit: boundaries.satMax - 0.5,  // Close to right edge
          nearDefectorsLimit: this.midpoint.loy - 1.5   // Close to bottom boundary
        };
      case 'defectors':
        return {
          nearHostagesLimit: boundaries.satMin + 1.5,   // Close to left edge
          nearMercenariesLimit: boundaries.loyMax - 1.5 // Close to top edge
        };
      default:
        return {};
    }
  }

  /**
   * Get space-aware proximity thresholds (now using available quadrant space)
   */
  getProximityThresholds(): ProximityThresholds {
    const boundaries = this.getScaleBoundaries();
    const scaleRange = boundaries.satMax - boundaries.satMin + 1;

    // Rule 1: No proximity for tiny scales
    if (scaleRange <= 3) {
      return { conservative: 0, moderate: 0, sensitive: 0 };
    }

    // Rule 2: Space-aware thresholds - use average quadrant space
    const avgSatSpace = (boundaries.satMax - this.midpoint.sat) / 2;
    const avgLoySpace = (boundaries.loyMax - this.midpoint.loy) / 2;
    const avgSpace = (avgSatSpace + avgLoySpace) / 2;

    return {
      conservative: Math.min(avgSpace * 0.5, 2.5),
      moderate: Math.min(avgSpace * 0.75, 2.5),
      sensitive: Math.min(avgSpace, 2.5)
    };
  }

  /**
   * Get the default proximity threshold for free users
   */
  getDefaultThreshold(): number {
    return this.getProximityThresholds().moderate;
  }

  /**
   * Check if proximity analysis is available for current scale
   */
  isProximityAvailable(): boolean {
    const maxSat = parseInt(this.satisfactionScale.split('-')[1]);
    const minSat = parseInt(this.satisfactionScale.split('-')[0]);
    const scaleRange = maxSat - minSat + 1;
    
    return scaleRange > 3; // No proximity for 1-3 scales
  }

  /**
   * Calculate distance from a point to all quadrant boundaries
   */
  calculateDistancesFromBoundaries(point: DataPoint): DistanceFromBoundary {
    const sat = point.satisfaction;
    const loy = point.loyalty;

    // Calculate absolute distances to midpoint boundaries
    const toLeft = Math.abs(sat - this.midpoint.sat);      // Distance to hostages boundary
    const toRight = Math.abs(sat - this.midpoint.sat);     // Distance to mercenaries boundary (same as left)
    const toBottom = Math.abs(loy - this.midpoint.loy);    // Distance to defectors boundary  
    const toTop = Math.abs(loy - this.midpoint.loy);       // Distance to loyalists boundary (same as bottom)

    // For boundary detection, we need actual directional distances
    const directionalDistances = {
      toLeft: sat >= this.midpoint.sat ? sat - this.midpoint.sat : 0,           // Only positive if right of midpoint
      toRight: sat <= this.midpoint.sat ? this.midpoint.sat - sat : 0,         // Only positive if left of midpoint
      toBottom: loy >= this.midpoint.loy ? loy - this.midpoint.loy : 0,        // Only positive if above midpoint
      toTop: loy <= this.midpoint.loy ? this.midpoint.loy - loy : 0,           // Only positive if below midpoint
    };

    // Calculate actual distances from boundaries based on current quadrant
    const currentQuadrant = this.determineQuadrant(point);
    let actualDistances: DistanceFromBoundary;

    switch (currentQuadrant) {
      case 'loyalists':
        
        actualDistances = {
          toLeft: sat - this.midpoint.sat,           // Distance to hostages
          toRight: Number.MAX_VALUE,                 // Not adjacent
          toBottom: loy - this.midpoint.loy,         // Distance to mercenaries
          toTop: Number.MAX_VALUE,                   // Not adjacent
          minimum: Math.min(sat - this.midpoint.sat, loy - this.midpoint.loy)
        };
        break;

      case 'mercenaries':
        actualDistances = {
          toLeft: Number.MAX_VALUE,                  // Not adjacent
          toRight: Number.MAX_VALUE,                 // Not adjacent
          toBottom: this.midpoint.loy - loy,         // Distance to defectors
          toTop: this.midpoint.loy - loy,            // Distance to loyalists
          minimum: this.midpoint.loy - loy
        };
        break;

      case 'hostages':
        actualDistances = {
          toLeft: this.midpoint.sat - sat,           // Distance to defectors
          toRight: this.midpoint.sat - sat,          // Distance to loyalists
          toBottom: Number.MAX_VALUE,                // Not adjacent
          toTop: loy - this.midpoint.loy,            // Distance to loyalists
          minimum: Math.min(this.midpoint.sat - sat, loy - this.midpoint.loy)
        };
        break;

      case 'defectors':
        actualDistances = {
          toLeft: this.midpoint.sat - sat,           // Distance to hostages
          toRight: Number.MAX_VALUE,                 // Not adjacent
          toBottom: this.midpoint.loy - loy,         // Distance to mercenaries
          toTop: Number.MAX_VALUE,                   // Not adjacent
          minimum: Math.min(this.midpoint.sat - sat, this.midpoint.loy - loy)
        };
        break;

      default:
        // For special zones, calculate based on position
        actualDistances = {
          toLeft: Math.abs(sat - this.midpoint.sat),
          toRight: Math.abs(sat - this.midpoint.sat),
          toBottom: Math.abs(loy - this.midpoint.loy),
          toTop: Math.abs(loy - this.midpoint.loy),
          minimum: Math.min(Math.abs(sat - this.midpoint.sat), Math.abs(loy - this.midpoint.loy))
        };
    }

    return actualDistances;
  }

  /**
   * Determine which quadrant a point belongs to (basic 4-quadrant logic)
   */
  private determineQuadrant(point: DataPoint): QuadrantType {
    const sat = point.satisfaction;
    const loy = point.loyalty;

    if (sat >= this.midpoint.sat && loy >= this.midpoint.loy) {
      return 'loyalists';
    } else if (sat >= this.midpoint.sat && loy < this.midpoint.loy) {
      return 'mercenaries'; 
    } else if (sat < this.midpoint.sat && loy >= this.midpoint.loy) {
      return 'hostages';
    } else {
      return 'defectors';
    }
  }

  /**
   * Check if a customer is within proximity threshold of any boundary
   */
  isWithinProximityThreshold(point: DataPoint, threshold: number): boolean {
    if (!this.isProximityAvailable()) {
      return false;
    }

    const distances = this.calculateDistancesFromBoundaries(point);
    return distances.minimum <= threshold;
  }

  /**
   * Get proximity classification using space-aware limits with proper null checks
   */
  getProximityClassification(point: DataPoint, threshold: number): {
    isProximity: boolean;
    proximityTargets: string[];
    minDistance: number;
    riskLevel: 'LOW' | 'MODERATE' | 'HIGH';
  } {
    const currentQuadrant = this.determineQuadrant(point);
    const limits = this.getSpaceAwareProximityLimits(currentQuadrant);
    const proximityTargets: string[] = [];
    let minDistance = Number.MAX_VALUE;

    // DEBUG: Log all loyalist coordinates and limits
    if (currentQuadrant === 'loyalists') {
      console.log(`ðŸ” LOYALIST: (${point.satisfaction}, ${point.loyalty}) | Limits: hostages=${limits.nearHostagesLimit}, mercenaries=${limits.nearMercenariesLimit}`);
    }

    // Use space-aware limits with null checks
    switch (currentQuadrant) {
      case 'loyalists':
        // Near hostages: sat between midpoint and nearHostagesLimit
        if (limits.nearHostagesLimit !== undefined && 
            point.satisfaction >= this.midpoint.sat && 
            point.satisfaction <= limits.nearHostagesLimit) {
          proximityTargets.push('hostages');
          minDistance = Math.min(minDistance, Math.abs(point.satisfaction - this.midpoint.sat));
        }
        // Near mercenaries: loy between midpoint and nearMercenariesLimit
        if (limits.nearMercenariesLimit !== undefined && 
            point.loyalty >= this.midpoint.loy && 
            point.loyalty <= limits.nearMercenariesLimit) {
          proximityTargets.push('mercenaries');
          minDistance = Math.min(minDistance, Math.abs(point.loyalty - this.midpoint.loy));
        }
        break;
      case 'mercenaries':
        // Near loyalists: loy above nearLoyalistsLimit
        if (limits.nearLoyalistsLimit !== undefined && 
            point.loyalty >= limits.nearLoyalistsLimit) {
          proximityTargets.push('loyalists');
          minDistance = Math.min(minDistance, Math.abs(point.loyalty - this.midpoint.loy));
        }
        // Near defectors: loy below nearDefectorsLimit
        if (limits.nearDefectorsLimit !== undefined && 
            point.loyalty <= limits.nearDefectorsLimit) {
          proximityTargets.push('defectors');
          minDistance = Math.min(minDistance, Math.abs(point.loyalty - this.midpoint.loy));
        }
        break;
      case 'hostages':
        // Near loyalists: sat above nearLoyalistsLimit
        if (limits.nearLoyalistsLimit !== undefined && 
            point.satisfaction >= limits.nearLoyalistsLimit) {
          proximityTargets.push('loyalists');
          minDistance = Math.min(minDistance, Math.abs(point.satisfaction - this.midpoint.sat));
        }
        // Near defectors: loy below nearDefectorsLimit
        if (limits.nearDefectorsLimit !== undefined && 
            point.loyalty <= limits.nearDefectorsLimit) {
          proximityTargets.push('defectors');
          minDistance = Math.min(minDistance, Math.abs(point.loyalty - this.midpoint.loy));
        }
        break;
      case 'defectors':
        // Near hostages: sat below nearHostagesLimit
        if (limits.nearHostagesLimit !== undefined && 
            point.satisfaction <= limits.nearHostagesLimit) {
          proximityTargets.push('hostages');
          minDistance = Math.min(minDistance, Math.abs(point.satisfaction - this.midpoint.sat));
        }
        // Near mercenaries: loy above nearMercenariesLimit
        if (limits.nearMercenariesLimit !== undefined && 
            point.loyalty >= limits.nearMercenariesLimit) {
          proximityTargets.push('mercenaries');
          minDistance = Math.min(minDistance, Math.abs(point.loyalty - this.midpoint.loy));
        }
        break;
    }

    const isProximity = proximityTargets.length > 0;
    
    if (!isProximity) {
      return {
        isProximity: false,
        proximityTargets: [],
        minDistance: Number.MAX_VALUE,
        riskLevel: 'LOW'
      };
    }

    // Determine risk level based on minimum distance
    let riskLevel: 'LOW' | 'MODERATE' | 'HIGH';
    if (minDistance <= 0.5) {
      riskLevel = 'HIGH';
    } else if (minDistance <= 1.0) {
      riskLevel = 'MODERATE';  
    } else {
      riskLevel = 'LOW';
    }

    return {
      isProximity: true,
      proximityTargets,
      minDistance,
      riskLevel
    };
  }

  /**
   * Get user-friendly explanation for proximity unavailability
   */
  getUnavailabilityReason(): string | null {
    if (!this.isProximityAvailable()) {
      const maxSat = parseInt(this.satisfactionScale.split('-')[1]);
      const minSat = parseInt(this.satisfactionScale.split('-')[0]);
      const scaleRange = maxSat - minSat + 1;
      
      return `Proximity analysis unavailable: ${scaleRange}-point scale too small (requires more than 3 points)`;
    }
    
    return null;
  }
}