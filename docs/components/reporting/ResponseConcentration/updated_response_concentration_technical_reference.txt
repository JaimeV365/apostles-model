# Response Concentration Technical Reference

## Architecture Overview

The Response Concentration component is a real-time data visualization module that displays patterns in customer response data. This technical reference provides comprehensive implementation details, data flow patterns, and integration guidelines.

```
src/components/reporting/components/ResponseConcentrationSection/
├── index.tsx           # Main component with real-time processing
└── styles.css          # Component-specific styles and legend styling
```

## Dependencies Map

```mermaid
graph TD
    A[ResponseConcentrationSection] --> B[MiniPlot]
    A --> C[CombinationDial]
    A --> D[ResponseSettings]
    A --> E[FilterPanel]
    B --> F[DataReport]
    C --> F
    D --> G[ResponseConcentrationSettings]
    E --> H[DataPoint]
    A --> F
    A --> G
    A --> H
    A --> I[Enhanced Combination Processing]
    I --> J[Real-time Updates]
```

## Component API

### Props Interface

```typescript
interface ResponseConcentrationProps {
  /** Report data containing statistics and common combinations */
  report: DataReport;
  
  /** Configuration for visualization elements */
  settings: ResponseConcentrationSettings;
  
  /** Callback for settings updates */
  onSettingsChange: (settings: ResponseConcentrationSettings) => void;
  
  /** Flag for premium feature access */
  isPremium: boolean;
  
  /** Raw data points for real-time processing and filtering */
  originalData?: DataPoint[];
}
```

### Enhanced Settings Interface

```typescript
interface ResponseConcentrationSettings {
  miniPlot: {
    /** Whether to use quadrant colors or custom color */
    useQuadrantColors: boolean;
    
    /** Custom colors for mini plot */
    customColors: Record<string, string>;
    
    /** Premium: Show/hide average position reference */
    showAverageDot: boolean;
    
    /** Phase 2: Premium frequency threshold */
    frequencyThreshold?: number;
    
    /** Phase 2: Premium multi-tier visualization */
    showTiers?: boolean;
    maxTiers?: number;
  };
  list: {
    /** Whether to use color coding in list */
    useColorCoding: boolean;
    
    /** Maximum items to show in list */
    maxItems: number;
  };
  dial: {
    /** Minimum value for dial */
    minValue: number;
    
    /** Maximum value for dial */
    maxValue: number;
    
    /** Custom colors for dial */
    customColors: {
      satisfaction: string;
      loyalty: string;
    };
  };
}
```

## Real-time Data Processing

### Enhanced Combination Algorithm

```typescript
const getEnhancedCombinations = (data: DataPoint[]): Combination[] => {
  if (!data || data.length === 0) return [];
  
  // Build frequency map
  const combinationMap = new Map<string, CombinationData>();
  
  data.filter(d => !d.excluded).forEach(d => {
    const key = `${d.satisfaction}-${d.loyalty}`;
    if (!combinationMap.has(key)) {
      combinationMap.set(key, {
        count: 1,
        satisfaction: d.satisfaction,
        loyalty: d.loyalty
      });
    } else {
      const current = combinationMap.get(key)!;
      current.count++;
    }
  });

  // Convert to combinations with percentage calculation
  const allCombinations = Array.from(combinationMap.values())
    .map(combo => ({
      satisfaction: combo.satisfaction,
      loyalty: combo.loyalty,
      count: combo.count,
      percentage: (combo.count / data.filter(d => !d.excluded).length) * 100
    }))
    .sort((a, b) => b.count - a.count);

  // Smart filtering algorithm
  const maxCount = allCombinations.length > 0 ? allCombinations[0].count : 0;
  
  if (maxCount >= 3) {
    // High-frequency data: Show top tier combinations
    return allCombinations
      .filter(combo => combo.count >= Math.max(3, maxCount * 0.8))
      .slice(0, 6);
  } else if (maxCount >= 2) {
    // Medium-frequency data: Show emerging patterns
    return allCombinations
      .filter(combo => combo.count >= 2)
      .slice(0, 8);
  } else {
    // Low-frequency data: Fall back to top combinations
    return allCombinations.slice(0, 2);
  }
};
```

## Styling Architecture

### Corrected CSS Structure

**IMPORTANT**: The CSS structure has been consolidated to avoid duplicate declarations that were causing layout issues.

```css
/* Main section container */
.response-concentration-section {
  position: relative;
  background: #f9fafb;
  border-radius: 0.5rem;
  padding: 1.5rem;
  margin-bottom: 1.5rem;
}

/* Grid layout (background/padding inherited from section) */
.response-concentration-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 2rem;
}

/* Individual column containers (CONSOLIDATED SINGLE DECLARATION) */
.concentration-column {
  background: white;
  border-radius: 0.5rem;
  padding: 1.5rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  border: 1px solid #e5e7eb;
  display: flex;
  flex-direction: column;
}

/* MiniPlot container with proper spacing */
.miniplot-container {
  width: 100%;
  height: 200px;
  background: #f9fafb;
  border-radius: 0.375rem;
  border: 1px solid #e5e7eb;
  margin-bottom: 1rem;
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 1.5rem 0.5rem 1.5rem 0rem;
}

/* Column headers without conflicting borders */
.concentration-column h5 {
  font-size: 0.875rem;
  font-weight: 600;
  color: #374151;
  margin: 0 0 1rem 0;
}
```

### MiniPlot Integration

**Enhanced MiniPlot Props**:
```typescript
interface MiniPlotProps {
  combinations: Array<{
    satisfaction: number;
    loyalty: number;
    count: number;
    percentage: number;
  }>;
  satisfactionScale: string;  // e.g., "1-5", "0-10"
  loyaltyScale: string;
  useQuadrantColors?: boolean;
  customColors?: Record<string, string>;
  averagePoint?: {
    satisfaction: number;
    loyalty: number;
  };
  showAverageDot?: boolean;
}
```

### Scale Format Support

```typescript
// Dynamic scale parsing
const [satisfactionMin, satisfactionMax] = satisfactionScale.split('-').map(Number);
const [loyaltyMin, loyaltyMax] = loyaltyScale.split('-').map(Number);

// Position calculation for any scale range
const x = (combo.satisfaction - satisfactionMin) / (satisfactionMax - satisfactionMin) * 100;
const y = (combo.loyalty - loyaltyMin) / (loyaltyMax - loyaltyMin) * 100;
```

### Average Position Reference

```typescript
// Average point rendering with conditional display
{averagePoint && showAverageDot && (
  <div
    className="mini-plot-point mini-plot-point--average"
    style={{
      left: `${((averagePoint.satisfaction - satisfactionMin) / (satisfactionMax - satisfactionMin)) * 100}%`,
      bottom: `${((averagePoint.loyalty - loyaltyMin) / (loyaltyMax - loyaltyMin)) * 100}%`,
    }}
    title={`Average: ${averagePoint.satisfaction.toFixed(1)}, ${averagePoint.loyalty.toFixed(1)}`}
  />
)}
```

## CSS Selectors Map

```
.response-concentration-section             # Main container with gray background
├── .response-concentration-header          # Header with title and controls
│   ├── .section-title-container            # Title and filter indicators
│   │   ├── h3                              # Section title
│   │   └── .filter-indicator               # Active filter count badge
│   └── .settings-button                    # Settings toggle (premium only)
├── .info-ribbon                            # Information banner
│   ├── .info-ribbon-content                # Banner text content
│   ├── .info-icon                          # Information icon
│   └── .info-ribbon-close                  # Close button
├── .response-concentration-grid            # Three-column layout grid
│   └── .concentration-column               # Individual white columns
│       ├── h5                              # Column headers
│       ├── .miniplot-container             # Gray plot container
│       │   └── .mini-plot                  # Actual MiniPlot component
│       ├── .combinations-list              # Combination list
│       │   ├── .combination-item           # List items
│       │   │   ├── .combination-marker     # Color dots
│       │   │   └── .combination-text       # Text content
│       │   │       ├── .combination-values # Coordinate values
│       │   │       └── .combination-stats  # Statistics
│       │   └── .tier-indicator             # Tier labels (Phase 2)
│       └── .miniplot-legend                # Legend below plot
│           ├── .legend-item                # Legend entries
│           │   ├── .legend-dot             # Legend markers
│           │   │   └── .average-dot        # Average position marker
│           │   └── .legend-text            # Legend labels
│           └── .tier-legend                # Tier legend (Phase 2)
└── .response-concentration-panel           # Settings/filters panel
    ├── .panel-header                       # Panel header
    │   ├── .panel-tabs                     # Tab navigation
    │   │   └── .panel-tab                  # Individual tabs
    │   └── .panel-close                    # Panel close button
    └── .panel-content                      # Panel content area
        ├── .embedded-settings              # Settings container
        └── .filter-wrapper                 # Filter container
```

## Visual Styling Guidelines

### Color System
- **Gray background**: `#f9fafb` (main section and miniplot container)
- **White background**: `white` (individual columns)
- **Border color**: `#e5e7eb` (consistent across components)
- **Brand green**: `#3a863e` (accent colors and indicators)

### Spacing System
- **Section padding**: `1.5rem` (main container)
- **Grid gap**: `2rem` (between columns)
- **Column padding**: `1.5rem` (internal spacing)
- **Component margins**: `1rem` (between internal elements)

### Typography
- **Section title**: `1rem, 600 weight, #374151`
- **Column headers**: `0.875rem, 600 weight, #374151`
- **Body text**: `0.875rem, normal weight, #374151`
- **Secondary text**: `0.75rem, normal weight, #6b7280`

## Performance Optimization

### Update Strategies

```typescript
// Performance-based update strategy
const getCalculationStrategy = (dataSize: number) => {
  if (dataSize < 1000) return 'realtime';      // Immediate updates
  if (dataSize < 10000) return 'debounced';    // 300ms debounce
  return 'manual';                             // Manual refresh
};
```

### Memory Management

```typescript
// Cleanup and optimization
useEffect(() => {
  return () => {
    // Cleanup subscriptions
    // Clear cached calculations
  };
}, []);
```

## Integration Guide

### Basic Implementation

```tsx
<ResponseConcentrationSection
  report={report}
  settings={settings}
  onSettingsChange={setSettings}
  isPremium={isPremium}
  originalData={data}
/>
```

### Advanced Configuration

```tsx
// Enhanced settings with Phase 2 features
const premiumSettings = {
  miniPlot: {
    useQuadrantColors: true,
    customColors: {},
    showAverageDot: true,
    frequencyThreshold: 2,        // Phase 2
    showTiers: false,             // Phase 2
    maxTiers: 2                   // Phase 2
  },
  list: {
    useColorCoding: true,
    maxItems: 10
  },
  dial: {
    minValue: 0,
    maxValue: 100,
    customColors: {
      satisfaction: '#4CAF50',
      loyalty: '#4682B4'
    }
  }
};
```

## Troubleshooting

### Common Issues

1. **Layout spacing problems**: Check for duplicate CSS declarations in `styles.css`
2. **Component overlap**: Verify container hierarchy and padding values
3. **Performance issues**: Implement appropriate update strategy based on data size

### CSS Architecture Best Practices

- **Avoid duplicate selectors**: Consolidate all properties into single declarations
- **Use consistent spacing**: Follow the established rem-based spacing system
- **Maintain container hierarchy**: Respect the gray-section → white-columns → gray-containers structure

## Version History

| Version | Date | Changes |
|---------|------|---------|
| 1.0.0 | 2023-09-01 | Initial implementation |
| 2.0.0 | 2024-01-14 | Real-time updates, enhanced patterns, average position reference |
| 2.1.0 | 2025-01-15 | Fixed CSS consolidation, improved spacing controls |

## Future Enhancements

### Planned Features (Phase 3)
- **Advanced Analytics**: Concentration density zones and trend detection
- **Performance Optimization**: Web workers for large datasets
- **Accessibility Enhancements**: Voice navigation and enhanced screen reader support

### API Evolution

```typescript
// Future API considerations
interface FutureResponseConcentrationProps extends ResponseConcentrationProps {
  // Time-series support
  timeSeriesData?: TimeSeriesPoint[];
  
  // Advanced analytics
  enableTrendAnalysis?: boolean;
  correlationThreshold?: number;
  
  // Enhanced visualization
  enable3D?: boolean;
  animationSpeed?: number;
  
  // Performance options
  useWebWorkers?: boolean;
  virtualScrolling?: boolean;
}
```

## Conclusion

The Response Concentration section represents a significant advancement in real-time data visualization, combining intelligent pattern detection, flexible scale support, and premium customization features. The implementation prioritizes performance, accessibility, and maintainability while providing a robust foundation for future enhancements.

Key achievements in version 2.1:
- ✅ Real-time data processing with smart filtering
- ✅ Multiple scale format support (1-5, 0-10, custom)
- ✅ Average position reference with premium controls
- ✅ Consolidated CSS architecture eliminating duplicate declarations
- ✅ Enhanced accessibility and keyboard navigation
- ✅ Phase 2 premium features (frequency controls and tiers)

This technical reference serves as the definitive guide for understanding, implementing, and maintaining the Response Concentration component system.